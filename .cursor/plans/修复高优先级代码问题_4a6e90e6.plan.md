---
name: 修复高优先级代码问题(终版)
overview: 修复 3 个高优先级问题（共涉及 4 个文件）：ImageStore FIFO 清理策略导致图片白块；ResizableImage schema 缺失 data-origin-src 属性导致图片无法恢复 + 保存丢失原始数据；useCollaboration 全局错误处理器引用计数异常路径不安全。
todos:
  - id: fix-imagestore
    content: 'imageStore.ts: 去除 FIFO 主动 revoke，改为惰性清理 + 提高上限到 500'
    status: completed
  - id: fix-image-schema
    content: 'ResizableImage.ts: 注册 data-origin-src 为 Tiptap 节点属性（修复隐性 bug）'
    status: completed
  - id: fix-image-recovery
    content: 'ResizableImageComponent.vue: handleImageError/retryLoadImage 增加 data-origin-src 自动恢复'
    status: completed
  - id: fix-error-handler
    content: 'useCollaboration.ts: 修复全局错误处理器引用计数保护 + 异常路径注销'
    status: completed
isProject: false
---

# 修复高优先级代码问题（终版方案）

排除 `getFileStream` API（后端返回 null 不改），排除 `imageMap` 内存泄漏（函数局部变量，GC 会回收）。实际修复 3 项问题，涉及 4 个文件。

## 1. ImageStore FIFO 清理策略 — `imageStore.ts`

### 问题

`registerBlobUrl` 超出 `MAX_BLOB_URLS = 200` 时直接 `URL.revokeObjectURL` 释放最早的 blob URL，但该 URL 可能仍在 DOM 中被 `<img>` 引用，导致图片白块。

### 修改

- `MAX_BLOB_URLS` 从 200 提高到 **500**（作为警告阈值，不再是清理阈值）
- `registerBlobUrl` 超限时**仅记录警告，不主动 revoke**
- `clear()` 保持不变（组件卸载时统一释放）

### 影响评估

- 不影响任何现有功能
- 正向改善大文档图片体验
- 内存影响可忽略（blob URL 字符串本身极小）

## 2. ResizableImage schema 缺失 data-origin-src — `ResizableImage.ts`

### 问题（深度分析发现的隐性 bug）

ImageStore 转换图片时在 HTML 中添加了 `data-origin-src` 属性保存原始 data URL，但 `ResizableImage.ts` 的 `addAttributes` 中**没有注册该属性**。导致：

1. Tiptap 解析 HTML 时丢弃 `data-origin-src`
2. `editor.getHTML()` 输出中不含 `data-origin-src`
3. 保存时 `restoreBlobImagesFromOrigin` 无法从 `data-origin-src` 恢复原始图片数据
4. ResizableImageComponent 中无法读取该属性做恢复

### 修改

在 `addAttributes()` 中添加 `data-origin-src` 属性定义：

```typescript
'data-origin-src': {
  default: null,
  parseHTML: (element) => element.getAttribute('data-origin-src'),
  renderHTML: (attributes) => {
    if (!attributes['data-origin-src']) return {}
    return { 'data-origin-src': attributes['data-origin-src'] }
  }
}
```

### 影响评估

- Y.js 兼容性：旧文档中图片节点没有此属性，新 schema 会给默认值 null，不会报错
- 新文档保存受益：`restoreBlobImagesFromOrigin` 可以正确工作
- HTML 输出：图片标签会多一个 `data-origin-src` 属性，不影响渲染

## 3. ResizableImageComponent 图片恢复 — `ResizableImageComponent.vue`

### 问题

`handleImageError` 只标记 `imageError = true`，不尝试恢复。`retryLoadImage` 用的还是失效的 blob URL，重试也没用。

### 修改

`handleImageError`：如果当前是 blob URL 且节点有 `data-origin-src`，自动回退到原始 data URL：

```typescript
const handleImageError = () => {
  const src = props.node.attrs.src || ''
  const originSrc = props.node.attrs['data-origin-src'] || ''
  if (src.startsWith('blob:') && originSrc.startsWith('data:')) {
    props.updateAttributes({ src: originSrc })
    return
  }
  imageError.value = true
}
```

`retryLoadImage`：增加同样的恢复逻辑，如果 blob URL 失效则尝试从 `data-origin-src` 恢复。

### 影响评估

- 仅在图片加载失败时触发，正常图片不受影响
- 恢复为 data URL 后图片可能略大（base64），但至少能显示
- 依赖修复 2（data-origin-src 需要在 schema 中注册才能读取）

## 4. useCollaboration 全局错误处理器 — `useCollaboration.ts`

### 问题

`unregisterYjsErrorHandler` 没有 count <= 0 保护，异常路径下 count 可能变为负数导致 `window.onerror` 异常；`initCollaboration` 异常时不注销已注册的处理器。

### 修改

`unregisterYjsErrorHandler` 添加保护：

```typescript
const unregisterYjsErrorHandler = () => {
  if (globalErrorHandlerRefCount <= 0) return
  globalErrorHandlerRefCount--
  if (globalErrorHandlerRefCount === 0 && originalOnError !== null) {
    window.onerror = originalOnError
    originalOnError = null
  }
}
```

`initCollaboration` 的 catch 块添加注销调用。

### 影响评估

- 纯防御性修复，正常路径完全不受影响
- 仅在异常/边界场景生效

## 涉及文件

- `[src/views/training/document/utils/imageStore.ts](src/views/training/document/utils/imageStore.ts)`
- `[src/views/training/document/components/toolbar/extensions/ResizableImage.ts](src/views/training/document/components/toolbar/extensions/ResizableImage.ts)`
- `[src/views/training/document/components/toolbar/extensions/ResizableImageComponent.vue](src/views/training/document/components/toolbar/extensions/ResizableImageComponent.vue)`
- `[src/lmHooks/useCollaboration.ts](src/lmHooks/useCollaboration.ts)`
