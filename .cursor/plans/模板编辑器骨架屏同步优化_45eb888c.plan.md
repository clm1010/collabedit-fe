---
name: 模板编辑器骨架屏同步优化
overview: 将模板管理编辑器（MarkdownCollaborativeEditor + MarkdownEditor）的骨架屏加载行为与演训方案编辑器保持一致：删除父组件骨架屏，骨架屏仅覆盖内容区域，工具栏直接渲染，内容实际加载完成后骨架屏淡出。
todos:
  - id: md-parent-state
    content: MarkdownCollaborativeEditor.vue 新增 contentApplied ref 和 isContentReady computed
    status: completed
  - id: md-parent-apply
    content: 在 applyInitialContent 的跳过分支(行440)和 finally 块(行503)中标记 contentApplied = true
    status: completed
  - id: md-parent-template
    content: 修改父模板：v-if 去掉 isCollaborationReady，添加 content-loading prop，v-else 改为空白占位
    status: completed
  - id: md-child-prop
    content: MarkdownEditor.vue 新增 contentLoading prop
    status: completed
  - id: md-child-toolbar
    content: 工具栏 v-if 去掉 !loading
    status: completed
  - id: md-child-overlay
    content: 内容区改为覆盖层模式 + Transition 淡出
    status: completed
  - id: md-child-styles
    content: 添加 position relative、overlay CSS、过渡动画样式
    status: completed
  - id: md-verify
    content: 检查 lint 错误
    status: completed
isProject: false
---

# 模板编辑器骨架屏同步优化（最终版）

## 现状分析

模板管理编辑器与演训方案编辑器结构高度一致，存在相同的骨架屏问题：

**父组件** [MarkdownCollaborativeEditor.vue](collabedit-fe/src/views/template/editor/MarkdownCollaborativeEditor.vue)

- 行 30-47：`v-if="isCollaborationReady && provider && ydoc && fragment"` 控制 MarkdownEditor 渲染
- `v-else` 显示全区域 `el-skeleton`（覆盖工具栏位置）
- `isCollaborationReady` 比 provider/ydoc/fragment 就绪时机晚得多（需等 sync 或 3s 超时），导致骨架屏显示时间过长

**子组件** [MarkdownEditor.vue](collabedit-fe/src/views/template/editor/components/MarkdownEditor.vue)

- 行 4：工具栏 `v-if="editor && !loading && editable"`
- 行 468：内容区 `v-if="loading || !editor"` 显示骨架屏
- `loading` 始终为 `false`（父组件硬编码），骨架屏在 editor 创建后消失，但内容尚未加载

**与演训编辑器的关键差异**：父组件 `v-if` 多了 `isCollaborationReady` 条件。演训编辑器仅用 `provider && ydoc && fragment`（同步创建，一帧即通过），已验证无 Yjs 初始化问题。两者使用相同的 `useCollaboration` hook 和 Tiptap Collaboration 扩展。

## 修改方案

### 修改 1：父组件 MarkdownCollaborativeEditor.vue

**a) 新增 `contentApplied` ref 和 `isContentReady` computed**（行 770 附近，`isCollaborationSynced` 声明之后）：

```typescript
const contentApplied = ref(false)

// 内容是否真正加载完成（控制子组件骨架屏）
const isContentReady = computed(() => {
  // 初始内容已应用（含协同同步已有内容跳过的情况）
  if (contentApplied.value) return true
  // 协同已同步 且 没有需要应用的初始内容（空文档）
  if (isCollaborationSynced.value && !initialMarkdownContent.value) return true
  return false
})
```

**b) 在 `applyInitialContent` 中标记 `contentApplied**`：

行 440（协同已有内容，跳过初始内容应用）：

```typescript
console.log('协同同步已有内容，跳过初始内容应用（防止覆盖/重复）')
initialMarkdownContent.value = ''
isFirstLoadWithContent.value = false
contentApplied.value = true // ← 新增
clearCachedContent()
return
```

行 503（finally 块，无论成功或失败都标记完成）：

```typescript
  } finally {
    isApplyingContent.value = false
    contentApplied.value = true  // ← 新增
  }
```

**c) 在 `documentId` watch 重置中添加 `contentApplied**`（行 864 附近）：

```typescript
watch(
  () => documentId.value,
  (newDocId) => {
    initialMarkdownContent.value = ''
    isFirstLoadWithContent.value = false
    isEditorReady.value = false
    isCollaborationSynced.value = false
    contentApplied.value = false // ← 新增
    pendingCacheKey.value = null
    // ... 其余不变
  }
)
```

**d) 修改模板**（行 29-47）：

```html
<!-- 改前 -->
<MarkdownEditor
  v-if="isCollaborationReady && provider && ydoc && fragment"
  ...
  :loading="false"
  ...
/>
<div v-else class="p-6 h-full">
  <el-skeleton :rows="12" animated />
</div>

<!-- 改后 -->
<MarkdownEditor
  v-if="provider && ydoc && fragment"
  ...
  :loading="false"
  :content-loading="!isContentReady"
  ...
/>
<!-- provider/ydoc/fragment 同步创建，此处仅存在一帧 -->
<div v-else class="h-full bg-gray-100"></div>
```

> v-if 去掉 `isCollaborationReady`：与演训编辑器保持一致（`provider && ydoc && fragment` 在 `initCollaboration()` 中同步创建）。`isCollaborationReady` 的 watch（行 882-891）仍保留，继续作为 `tryApplyInitialContent` 的触发源。

### 修改 2：子组件 MarkdownEditor.vue

**a) 新增 prop `contentLoading**`（行 663 Props 接口）：

```typescript
interface Props {
  // ... 现有 props
  contentLoading?: boolean // 内容是否仍在加载中（由父组件控制）
}

const props = withDefaults(defineProps<Props>(), {
  // ... 现有默认值
  contentLoading: false
})
```

**b) 工具栏去掉 `!loading**`（行 4）：

```html
<!-- 改前 -->
<div v-if="editor && !loading && editable" class="editor-toolbar">
  <!-- 改后 -->
  <div v-if="editor && editable" class="editor-toolbar"></div
></div>
```

**c) 内容区从 v-if/v-else 改为覆盖层模式**（行 467-471）：

```html
<!-- 改前 -->
<div class="editor-content-wrapper" ref="contentWrapperRef">
  <div v-if="loading || !editor" class="p-6 h-full">
    <el-skeleton :rows="12" animated />
  </div>
  <template v-else>
    <div class="page-container"> ... </div>
  </template>
</div>

<!-- 改后 -->
<div class="editor-content-wrapper" ref="contentWrapperRef">
  <Transition name="skeleton-fade">
    <div v-if="contentLoading || !editor" class="content-skeleton-overlay">
      <div class="a4-skeleton-box">
        <el-skeleton :rows="12" animated />
      </div>
    </div>
  </Transition>
  <template v-if="editor">
    <div class="page-container"> ... (原有内容不变) </div>
  </template>
</div>
```

**d) CSS 样式**（行 1720 `.editor-content-wrapper` 之后）：

给 `.editor-content-wrapper` 添加 `position: relative`：

```scss
.editor-content-wrapper {
  position: relative; // ← 新增
  flex: 1;
  overflow-y: auto;
  overflow-x: auto;
  background: #e8eaed;
  // ... 其余不变
}
```

新增覆盖层和过渡样式（与 TiptapEditor 一致）：

```scss
.content-skeleton-overlay {
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  z-index: 10;
  background: #e8eaed;
  overflow: hidden;
}

.a4-skeleton-box {
  max-width: 794px;
  margin: 24px auto;
  padding: 40px 60px;
  background: #fff;
  border-radius: 4px;
  box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
}

.skeleton-fade-leave-active {
  transition: opacity 0.3s ease;
}

.skeleton-fade-leave-to {
  opacity: 0;
}
```

## 影响评估

- **组件使用范围**：MarkdownEditor 仅被 MarkdownCollaborativeEditor 使用，MarkdownCollaborativeEditor 仅被路由 `/template/editor/:id` 使用，修改完全隔离
- `**loading` prop：仅在工具栏（行 4）和内容骨架（行 468）中使用，无其他引用。MarkdownEditor 无回到顶部按钮，无需额外处理
- **v-if 去掉 `isCollaborationReady**`：`isCollaborationReady`的 watch（行 882）不受影响，仍正常触发`tryApplyInitialContent`。演训编辑器已验证 `provider && ydoc && fragment` 条件的安全性
- `**documentId` watch 重置：已包含 `contentApplied.value = false`，切换文档时状态正确重置
- **安全超时**：3s sync 超时（useCollaboration）+ 8s 安全超时（行 902-911）均不受影响，确保骨架屏不会永远停留
